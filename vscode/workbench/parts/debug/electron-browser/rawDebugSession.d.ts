import uri from 'vs/base/common/uri';
import Event from 'vs/base/common/event';
import { TPromise } from 'vs/base/common/winjs.base';
import { IMessageService } from 'vs/platform/message/common/message';
import { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';
import { ITerminalService } from 'vs/workbench/parts/terminal/common/terminal';
import { ITerminalService as IExternalTerminalService } from 'vs/workbench/parts/execution/common/execution';
import debug = require('vs/workbench/parts/debug/common/debug');
import { Adapter } from 'vs/workbench/parts/debug/node/debugAdapter';
import { V8Protocol } from 'vs/workbench/parts/debug/node/v8Protocol';
import { IOutputService } from 'vs/workbench/parts/output/common/output';
import { IConfigurationService } from 'vs/platform/configuration/common/configuration';
export interface SessionExitedEvent extends debug.DebugEvent {
    body: {
        exitCode: number;
        sessionId: string;
    };
}
export interface SessionTerminatedEvent extends debug.DebugEvent {
    body: {
        restart?: boolean;
        sessionId: string;
    };
}
export declare class RawDebugSession extends V8Protocol implements debug.ISession {
    private debugServerPort;
    private adapter;
    private customTelemetryService;
    root: uri;
    private messageService;
    private telemetryService;
    private outputService;
    private terminalService;
    private nativeTerminalService;
    private configurationService;
    emittedStopped: boolean;
    readyForBreakpoints: boolean;
    private serverProcess;
    private socket;
    private cachedInitServer;
    private startTime;
    disconnected: boolean;
    private sentPromises;
    private _capabilities;
    private allThreadsContinued;
    private _onDidInitialize;
    private _onDidStop;
    private _onDidContinued;
    private _onDidTerminateDebugee;
    private _onDidExitAdapter;
    private _onDidThread;
    private _onDidOutput;
    private _onDidBreakpoint;
    private _onDidCustomEvent;
    private _onDidEvent;
    constructor(id: string, debugServerPort: number, adapter: Adapter, customTelemetryService: ITelemetryService, root: uri, messageService: IMessageService, telemetryService: ITelemetryService, outputService: IOutputService, terminalService: ITerminalService, nativeTerminalService: IExternalTerminalService, configurationService: IConfigurationService);
    readonly onDidInitialize: Event<DebugProtocol.InitializedEvent>;
    readonly onDidStop: Event<DebugProtocol.StoppedEvent>;
    readonly onDidContinued: Event<DebugProtocol.ContinuedEvent>;
    readonly onDidTerminateDebugee: Event<SessionTerminatedEvent>;
    readonly onDidExitAdapter: Event<SessionExitedEvent>;
    readonly onDidThread: Event<DebugProtocol.ThreadEvent>;
    readonly onDidOutput: Event<DebugProtocol.OutputEvent>;
    readonly onDidBreakpoint: Event<DebugProtocol.BreakpointEvent>;
    readonly onDidCustomEvent: Event<debug.DebugEvent>;
    readonly onDidEvent: Event<DebugProtocol.Event>;
    private initServer();
    custom(request: string, args: any): TPromise<DebugProtocol.Response>;
    protected send<R extends DebugProtocol.Response>(command: string, args: any, cancelOnDisconnect?: boolean): TPromise<R>;
    protected onEvent(event: debug.DebugEvent): void;
    readonly capabilities: DebugProtocol.Capabilities;
    initialize(args: DebugProtocol.InitializeRequestArguments): TPromise<DebugProtocol.InitializeResponse>;
    private readCapabilities(response);
    launch(args: DebugProtocol.LaunchRequestArguments): TPromise<DebugProtocol.LaunchResponse>;
    attach(args: DebugProtocol.AttachRequestArguments): TPromise<DebugProtocol.AttachResponse>;
    next(args: DebugProtocol.NextArguments): TPromise<DebugProtocol.NextResponse>;
    stepIn(args: DebugProtocol.StepInArguments): TPromise<DebugProtocol.StepInResponse>;
    stepOut(args: DebugProtocol.StepOutArguments): TPromise<DebugProtocol.StepOutResponse>;
    continue(args: DebugProtocol.ContinueArguments): TPromise<DebugProtocol.ContinueResponse>;
    pause(args: DebugProtocol.PauseArguments): TPromise<DebugProtocol.PauseResponse>;
    setVariable(args: DebugProtocol.SetVariableArguments): TPromise<DebugProtocol.SetVariableResponse>;
    restartFrame(args: DebugProtocol.RestartFrameArguments, threadId: number): TPromise<DebugProtocol.RestartFrameResponse>;
    completions(args: DebugProtocol.CompletionsArguments): TPromise<DebugProtocol.CompletionsResponse>;
    disconnect(restart?: boolean, force?: boolean): TPromise<DebugProtocol.DisconnectResponse>;
    setBreakpoints(args: DebugProtocol.SetBreakpointsArguments): TPromise<DebugProtocol.SetBreakpointsResponse>;
    setFunctionBreakpoints(args: DebugProtocol.SetFunctionBreakpointsArguments): TPromise<DebugProtocol.SetFunctionBreakpointsResponse>;
    setExceptionBreakpoints(args: DebugProtocol.SetExceptionBreakpointsArguments): TPromise<DebugProtocol.SetExceptionBreakpointsResponse>;
    configurationDone(): TPromise<DebugProtocol.ConfigurationDoneResponse>;
    stackTrace(args: DebugProtocol.StackTraceArguments): TPromise<DebugProtocol.StackTraceResponse>;
    exceptionInfo(args: DebugProtocol.ExceptionInfoArguments): TPromise<DebugProtocol.ExceptionInfoResponse>;
    scopes(args: DebugProtocol.ScopesArguments): TPromise<DebugProtocol.ScopesResponse>;
    variables(args: DebugProtocol.VariablesArguments): TPromise<DebugProtocol.VariablesResponse>;
    source(args: DebugProtocol.SourceArguments): TPromise<DebugProtocol.SourceResponse>;
    threads(): TPromise<DebugProtocol.ThreadsResponse>;
    evaluate(args: DebugProtocol.EvaluateArguments): TPromise<DebugProtocol.EvaluateResponse>;
    stepBack(args: DebugProtocol.StepBackArguments): TPromise<DebugProtocol.StepBackResponse>;
    reverseContinue(args: DebugProtocol.ReverseContinueArguments): TPromise<DebugProtocol.ReverseContinueResponse>;
    getLengthInSeconds(): number;
    protected dispatchRequest(request: DebugProtocol.Request, response: DebugProtocol.Response): void;
    private fireFakeContinued(threadId, allThreadsContinued?);
    private connectServer(port);
    private startServer();
    private launchServer(launch);
    private stopServer();
    protected onServerError(err: Error): void;
    private onServerExit();
    dispose(): void;
}
