import Event from 'vs/base/common/event';
import { EditorInput, IEditorStacksModel, IEditorGroup, IEditorIdentifier, IEditorCloseEvent, GroupIdentifier, IStacksModelChangeEvent } from 'vs/workbench/common/editor';
import URI from 'vs/base/common/uri';
import { IStorageService } from 'vs/platform/storage/common/storage';
import { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';
import { IConfigurationService } from 'vs/platform/configuration/common/configuration';
import { ILifecycleService } from 'vs/platform/lifecycle/common/lifecycle';
import { Position, Direction } from 'vs/platform/editor/common/editor';
export interface EditorCloseEvent extends IEditorCloseEvent {
    editor: EditorInput;
}
export interface EditorIdentifier extends IEditorIdentifier {
    group: EditorGroup;
    editor: EditorInput;
}
export interface IEditorOpenOptions {
    pinned?: boolean;
    active?: boolean;
    index?: number;
}
export interface ISerializedEditorInput {
    id: string;
    value: string;
}
export interface ISerializedEditorGroup {
    label: string;
    editors: ISerializedEditorInput[];
    mru: number[];
    preview: number;
}
export declare class EditorGroup implements IEditorGroup {
    private instantiationService;
    private configurationService;
    private static IDS;
    private _id;
    private _label;
    private editors;
    private mru;
    private mapResourceToEditorCount;
    private preview;
    private active;
    private toDispose;
    private editorOpenPositioning;
    private _onEditorActivated;
    private _onEditorOpened;
    private _onEditorClosed;
    private _onEditorDisposed;
    private _onEditorDirty;
    private _onEditorLabelChange;
    private _onEditorMoved;
    private _onEditorPinned;
    private _onEditorUnpinned;
    private _onEditorStateChanged;
    private _onEditorsStructureChanged;
    constructor(arg1: string | ISerializedEditorGroup, instantiationService: IInstantiationService, configurationService: IConfigurationService);
    private registerListeners();
    private onConfigurationUpdated(config);
    readonly id: GroupIdentifier;
    label: string;
    readonly count: number;
    readonly onEditorActivated: Event<EditorInput>;
    readonly onEditorOpened: Event<EditorInput>;
    readonly onEditorClosed: Event<EditorCloseEvent>;
    readonly onEditorDisposed: Event<EditorInput>;
    readonly onEditorDirty: Event<EditorInput>;
    readonly onEditorLabelChange: Event<EditorInput>;
    readonly onEditorMoved: Event<EditorInput>;
    readonly onEditorPinned: Event<EditorInput>;
    readonly onEditorUnpinned: Event<EditorInput>;
    readonly onEditorStateChanged: Event<EditorInput>;
    readonly onEditorsStructureChanged: Event<EditorInput>;
    getEditors(mru?: boolean): EditorInput[];
    getEditor(index: number): EditorInput;
    getEditor(resource: URI): EditorInput;
    readonly activeEditor: EditorInput;
    isActive(editor: EditorInput): boolean;
    readonly previewEditor: EditorInput;
    isPreview(editor: EditorInput): boolean;
    openEditor(editor: EditorInput, options?: IEditorOpenOptions): void;
    private hookEditorListeners(editor);
    replaceEditor(toReplace: EditorInput, replaceWidth: EditorInput, replaceIndex: number, openNext?: boolean): void;
    closeEditor(editor: EditorInput, openNext?: boolean): void;
    private doCloseEditor(editor, openNext?);
    closeEditors(except: EditorInput, direction?: Direction): void;
    closeAllEditors(): void;
    moveEditor(editor: EditorInput, toIndex: number): void;
    setActive(editor: EditorInput): void;
    pin(editor: EditorInput): void;
    unpin(editor: EditorInput): void;
    isPinned(editor: EditorInput): boolean;
    isPinned(index: number): boolean;
    private fireEvent(emitter, arg2, isStructuralChange);
    private splice(index, del, editor?);
    private updateResourceMap(editor, remove);
    indexOf(candidate: EditorInput, editors?: EditorInput[]): number;
    contains(editorOrResource: EditorInput | URI): boolean;
    private setMostRecentlyUsed(editor);
    private matches(editorA, editorB);
    serialize(): ISerializedEditorGroup;
    private deserialize(data);
    dispose(): void;
}
export declare class EditorStacksModel implements IEditorStacksModel {
    private restoreFromStorage;
    private storageService;
    private lifecycleService;
    private instantiationService;
    private static STORAGE_KEY;
    private toDispose;
    private loaded;
    private _groups;
    private _activeGroup;
    private groupToIdentifier;
    private _onGroupOpened;
    private _onGroupClosed;
    private _onGroupMoved;
    private _onGroupActivated;
    private _onGroupDeactivated;
    private _onGroupRenamed;
    private _onEditorDisposed;
    private _onEditorDirty;
    private _onEditorLabelChange;
    private _onEditorOpened;
    private _onWillCloseEditor;
    private _onEditorClosed;
    private _onModelChanged;
    constructor(restoreFromStorage: boolean, storageService: IStorageService, lifecycleService: ILifecycleService, instantiationService: IInstantiationService);
    private registerListeners();
    readonly onGroupOpened: Event<EditorGroup>;
    readonly onGroupClosed: Event<EditorGroup>;
    readonly onGroupActivated: Event<EditorGroup>;
    readonly onGroupDeactivated: Event<EditorGroup>;
    readonly onGroupMoved: Event<EditorGroup>;
    readonly onGroupRenamed: Event<EditorGroup>;
    readonly onModelChanged: Event<IStacksModelChangeEvent>;
    readonly onEditorDisposed: Event<EditorIdentifier>;
    readonly onEditorDirty: Event<EditorIdentifier>;
    readonly onEditorLabelChange: Event<EditorIdentifier>;
    readonly onEditorOpened: Event<EditorIdentifier>;
    readonly onWillCloseEditor: Event<EditorCloseEvent>;
    readonly onEditorClosed: Event<EditorCloseEvent>;
    readonly groups: EditorGroup[];
    readonly activeGroup: EditorGroup;
    isActive(group: EditorGroup): boolean;
    getGroup(id: GroupIdentifier): EditorGroup;
    openGroup(label: string, activate?: boolean, index?: number): EditorGroup;
    renameGroup(group: EditorGroup, label: string): void;
    closeGroup(group: EditorGroup): void;
    closeGroups(except?: EditorGroup): void;
    setActive(group: EditorGroup): void;
    moveGroup(group: EditorGroup, toIndex: number): void;
    private indexOf(group);
    findGroup(editor: EditorInput, activeOnly?: boolean): EditorGroup;
    positionOfGroup(group: IEditorGroup): Position;
    positionOfGroup(group: EditorGroup): Position;
    groupAt(position: Position): EditorGroup;
    next(jumpGroups: boolean, cycleAtEnd?: boolean): IEditorIdentifier;
    previous(jumpGroups: boolean, cycleAtStart?: boolean): IEditorIdentifier;
    private save();
    private serialize();
    private fireEvent(emitter, group, isStructuralChange);
    private ensureLoaded();
    private load();
    private doValidate(serialized);
    private doCreateGroup(arg1);
    private handleOnEditorClosed(event);
    isOpen(editorOrResource: URI | EditorInput): boolean;
    count(editor: EditorInput): number;
    private onShutdown();
    validate(): void;
    toString(): string;
}
