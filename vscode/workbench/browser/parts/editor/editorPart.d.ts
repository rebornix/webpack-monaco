import 'vs/css!./media/editorpart';
import 'vs/workbench/browser/parts/editor/editor.contribution';
import { TPromise } from 'vs/base/common/winjs.base';
import { Dimension, Builder } from 'vs/base/browser/builder';
import { Part } from 'vs/workbench/browser/part';
import { BaseEditor } from 'vs/workbench/browser/parts/editor/baseEditor';
import { EditorInput, EditorOptions } from 'vs/workbench/common/editor';
import { IEditorGroupService, GroupOrientation, GroupArrangement, ITabOptions, IMoveOptions } from 'vs/workbench/services/group/common/groupService';
import { IConfigurationService } from 'vs/platform/configuration/common/configuration';
import { IEditorPart } from 'vs/workbench/services/editor/browser/editorService';
import { IPartService } from 'vs/workbench/services/part/common/partService';
import { Position, Direction } from 'vs/platform/editor/common/editor';
import { IStorageService } from 'vs/platform/storage/common/storage';
import { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';
import { IMessageService } from 'vs/platform/message/common/message';
import { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';
import { EditorStacksModel, EditorGroup } from 'vs/workbench/common/editor/editorStacksModel';
import Event from 'vs/base/common/event';
import { IContextKeyService } from 'vs/platform/contextkey/common/contextkey';
import { IThemeService } from 'vs/platform/theme/common/themeService';
import { IEnvironmentService } from 'vs/platform/environment/common/environment';
/**
 * The editor part is the container for editors in the workbench. Based on the editor input being opened, it asks the registered
 * editor for the given input to show the contents. The editor part supports up to 3 side-by-side editors.
 */
export declare class EditorPart extends Part implements IEditorPart, IEditorGroupService {
    private messageService;
    private telemetryService;
    private storageService;
    private partService;
    private configurationService;
    private instantiationService;
    private environmentService;
    _serviceBrand: any;
    private static GROUP_LEFT;
    private static GROUP_CENTER;
    private static GROUP_RIGHT;
    private static GROUP_TOP;
    private static GROUP_MIDDLE;
    private static GROUP_BOTTOM;
    private static EDITOR_PART_UI_STATE_STORAGE_KEY;
    private dimension;
    private editorGroupsControl;
    private memento;
    private stacks;
    private tabOptions;
    private forceHideTabs;
    private doNotFireTabOptionsChanged;
    private revealIfOpen;
    private _onEditorsChanged;
    private _onEditorsMoved;
    private _onEditorOpenFail;
    private _onGroupOrientationChanged;
    private _onTabOptionsChanged;
    private textCompareEditorVisible;
    private visibleEditors;
    private instantiatedEditors;
    private mapEditorInstantiationPromiseToEditor;
    private editorOpenToken;
    private pendingEditorInputsToClose;
    private pendingEditorInputCloseTimeout;
    private onLayoutEmitter;
    onLayout: Event<Dimension>;
    constructor(id: string, restoreFromStorage: boolean, messageService: IMessageService, telemetryService: ITelemetryService, storageService: IStorageService, partService: IPartService, configurationService: IConfigurationService, contextKeyService: IContextKeyService, instantiationService: IInstantiationService, themeService: IThemeService, environmentService: IEnvironmentService);
    private initStyles();
    private registerListeners();
    private onEditorGroupOpenedOrClosed();
    private onConfigurationUpdated(configuration);
    private onEditorDirty(identifier);
    private onEditorDisposed(identifier);
    private onEditorOpened(identifier);
    private onEditorClosed(event);
    hideTabs(forceHide: boolean): void;
    resizeGroup(position: Position, groupSizeChange: number): void;
    readonly onEditorsChanged: Event<void>;
    readonly onEditorsMoved: Event<void>;
    readonly onEditorOpenFail: Event<EditorInput>;
    readonly onGroupOrientationChanged: Event<void>;
    readonly onTabOptionsChanged: Event<ITabOptions>;
    getTabOptions(): ITabOptions;
    openEditor(input: EditorInput, options?: EditorOptions, sideBySide?: boolean): TPromise<BaseEditor>;
    openEditor(input: EditorInput, options?: EditorOptions, position?: Position, ratio?: number[]): TPromise<BaseEditor>;
    private doOpenEditor(position, descriptor, input, options, ratio);
    private doShowEditor(group, descriptor, input, options, ratio, monitor);
    private doCreateEditor(group, descriptor, monitor);
    private doInstantiateEditor(group, descriptor);
    private doSetInput(group, editor, input, options, monitor);
    private doHandleSetInputError(e, group, editor, input, options, monitor);
    closeEditor(position: Position, input: EditorInput): TPromise<void>;
    private doCloseEditor(group, input, focusNext?);
    private doCloseActiveEditor(group, focusNext?);
    private doCloseInactiveEditor(group, input);
    private doCloseGroup(group, focusNext?);
    private doHideEditor(editor, position, layoutAndRochade);
    private updateTextCompareEditorVisible();
    closeAllEditors(except?: Position): TPromise<void>;
    closeEditors(position: Position, filter?: {
        except?: EditorInput;
        direction?: Direction;
        unmodifiedOnly?: boolean;
    }): TPromise<void>;
    private doCloseEditors(group, filter?);
    private handleDirty(identifiers, ignoreIfOpenedInOtherGroup?);
    private doHandleDirty(identifier, ignoreIfOpenedInOtherGroup?);
    private countEditors(editor);
    getStacksModel(): EditorStacksModel;
    getActiveEditorInput(): EditorInput;
    getActiveEditor(): BaseEditor;
    getVisibleEditors(): BaseEditor[];
    moveGroup(from: EditorGroup, to: EditorGroup): void;
    moveGroup(from: Position, to: Position): void;
    moveEditor(input: EditorInput, from: EditorGroup, to: EditorGroup, moveOptions?: IMoveOptions): void;
    moveEditor(input: EditorInput, from: Position, to: Position, moveOptions?: IMoveOptions): void;
    private doMoveEditorInsideGroups(input, group, moveOptions?);
    private doMoveEditorAcrossGroups(input, fromGroup, to, moveOptions?);
    arrangeGroups(arrangement: GroupArrangement): void;
    setGroupOrientation(orientation: GroupOrientation): void;
    getGroupOrientation(): GroupOrientation;
    createContentArea(parent: Builder): Builder;
    protected updateStyles(): void;
    private onGroupFocusChanged();
    replaceEditors(editors: {
        toReplace: EditorInput;
        replaceWith: EditorInput;
        options?: EditorOptions;
    }[], position?: Position): TPromise<BaseEditor[]>;
    openEditors(editors: {
        input: EditorInput;
        position: Position;
        options?: EditorOptions;
    }[]): TPromise<BaseEditor[]>;
    hasEditorsToRestore(): boolean;
    restoreEditors(): TPromise<BaseEditor[]>;
    private doOpenEditors(editors, activePosition?, ratio?);
    activateGroup(group: EditorGroup): void;
    activateGroup(position: Position): void;
    focusGroup(group: EditorGroup): void;
    focusGroup(position: Position): void;
    pinEditor(group: EditorGroup, input: EditorInput): void;
    pinEditor(position: Position, input: EditorInput): void;
    unpinEditor(group: EditorGroup, input: EditorInput): void;
    unpinEditor(position: Position, input: EditorInput): void;
    layout(dimension: Dimension): Dimension[];
    shutdown(): void;
    dispose(): void;
    private findPosition(input, options?, sideBySide?, ratio?);
    private findPosition(input, options?, desiredPosition?, ratio?);
    private startDelayedCloseEditorsFromInputDispose();
    private rochade(rochade);
    private rochade(from, to);
    private doRochade(array, from, to, empty);
    private ensureGroup(position, activate?);
    private modifyGroups(modification);
    private renameGroups();
    private hasGroup(position);
}
