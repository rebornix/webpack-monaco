import 'vs/workbench/parts/files/browser/files.contribution';
import { FileEditorInput } from 'vs/workbench/parts/files/common/editors/fileEditorInput';
import { Promise, TPromise } from 'vs/base/common/winjs.base';
import { EventEmitter } from 'vs/base/common/eventEmitter';
import URI from 'vs/base/common/uri';
import { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';
import { IEditorGroup, ConfirmResult } from 'vs/workbench/common/editor';
import Event from 'vs/base/common/event';
import Severity from 'vs/base/common/severity';
import { IBackupFileService } from 'vs/workbench/services/backup/common/backup';
import { IConfigurationService } from 'vs/platform/configuration/common/configuration';
import { IStorageService, StorageScope } from 'vs/platform/storage/common/storage';
import { IPartService, Parts } from 'vs/workbench/services/part/common/partService';
import { IEditorInput, IEditorOptions, Position, Direction, IEditor, IResourceInput, ITextEditorOptions } from 'vs/platform/editor/common/editor';
import { IUntitledEditorService } from 'vs/workbench/services/untitled/common/untitledEditorService';
import { IMessageService, IConfirmation } from 'vs/platform/message/common/message';
import { ILegacyWorkspace, IWorkspaceContextService, IWorkspace as IWorkbenchWorkspace } from 'vs/platform/workspace/common/workspace';
import { ILifecycleService, ShutdownEvent, ShutdownReason, StartupKind, LifecyclePhase } from 'vs/platform/lifecycle/common/lifecycle';
import { EditorStacksModel } from 'vs/workbench/common/editor/editorStacksModel';
import { IEditorGroupService, GroupArrangement, GroupOrientation, ITabOptions, IMoveOptions } from 'vs/workbench/services/group/common/groupService';
import { TextFileService } from 'vs/workbench/services/textfile/common/textFileService';
import { FileOperationEvent, IFileService, IResolveContentOptions, FileOperationError, IFileStat, IResolveFileResult, IImportResult, FileChangesEvent, IResolveFileOptions, IContent, IUpdateContentOptions, IStreamContent } from 'vs/platform/files/common/files';
import { IRawTextContent } from 'vs/workbench/services/textfile/common/textfiles';
import { EnvironmentService } from 'vs/platform/environment/node/environmentService';
import { IWorkbenchEditorService } from 'vs/workbench/services/editor/common/editorService';
import { IHistoryService } from 'vs/workbench/services/history/common/history';
import { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';
import { IWindowsService, IWindowService, INativeOpenDialogOptions } from 'vs/platform/windows/common/windows';
import { IRawTextSource } from 'vs/editor/common/model/textSource';
import { IWorkspaceIdentifier } from 'vs/platform/workspaces/common/workspaces';
import { IRecentlyOpened } from 'vs/platform/history/common/history';
export declare function createFileInput(instantiationService: IInstantiationService, resource: URI): FileEditorInput;
export declare const TestEnvironmentService: EnvironmentService;
export declare class TestContextService implements IWorkspaceContextService {
    _serviceBrand: any;
    private workspace;
    private id;
    private options;
    private _onDidChangeWorkspaceName;
    private _onDidChangeWorkspaceRoots;
    constructor(workspace?: any, options?: any);
    readonly onDidChangeWorkspaceName: Event<void>;
    readonly onDidChangeWorkspaceRoots: Event<void>;
    getFolders(): URI[];
    hasWorkspace(): boolean;
    hasFolderWorkspace(): boolean;
    hasMultiFolderWorkspace(): boolean;
    getLegacyWorkspace(): ILegacyWorkspace;
    getWorkspace(): IWorkbenchWorkspace;
    getRoot(resource: URI): URI;
    setWorkspace(workspace: any): void;
    getOptions(): any;
    updateOptions(): void;
    isInsideWorkspace(resource: URI): boolean;
    toResource(workspaceRelativePath: string): URI;
}
export declare class TestTextFileService extends TextFileService {
    cleanupBackupsBeforeShutdownCalled: boolean;
    private promptPath;
    private confirmResult;
    private resolveTextContentError;
    constructor(lifecycleService: ILifecycleService, contextService: IWorkspaceContextService, configurationService: IConfigurationService, telemetryService: ITelemetryService, editorService: IWorkbenchEditorService, fileService: IFileService, untitledEditorService: IUntitledEditorService, instantiationService: IInstantiationService, messageService: IMessageService, backupFileService: IBackupFileService, windowsService: IWindowsService, historyService: IHistoryService);
    setPromptPath(path: string): void;
    setConfirmResult(result: ConfirmResult): void;
    setResolveTextContentErrorOnce(error: FileOperationError): void;
    resolveTextContent(resource: URI, options?: IResolveContentOptions): TPromise<IRawTextContent>;
    promptForPath(defaultPath?: string): string;
    confirmSave(resources?: URI[]): ConfirmResult;
    onConfigurationChange(configuration: any): void;
    protected cleanupBackupsBeforeShutdown(): TPromise<void>;
}
export declare function workbenchInstantiationService(): IInstantiationService;
export declare class TestHistoryService implements IHistoryService {
    private root;
    _serviceBrand: any;
    constructor(root?: URI);
    reopenLastClosedEditor(): void;
    add(input: IEditorInput, options?: ITextEditorOptions): void;
    forward(acrossEditors?: boolean): void;
    back(acrossEditors?: boolean): void;
    remove(input: IEditorInput | IResourceInput): void;
    clear(): void;
    getHistory(): (IEditorInput | IResourceInput)[];
    getLastActiveWorkspaceRoot(): URI;
}
export declare class TestMessageService implements IMessageService {
    _serviceBrand: any;
    private counter;
    constructor();
    show(sev: Severity, message: any): () => void;
    getCounter(): number;
    hideAll(): void;
    confirm(confirmation: IConfirmation): boolean;
}
export declare class TestPartService implements IPartService {
    _serviceBrand: any;
    private _onTitleBarVisibilityChange;
    private _onEditorLayout;
    readonly onTitleBarVisibilityChange: Event<void>;
    readonly onEditorLayout: Event<void>;
    layout(): void;
    isCreated(): boolean;
    joinCreation(): Promise;
    hasFocus(part: any): boolean;
    isVisible(part: any): boolean;
    getContainer(part: any): HTMLElement;
    isTitleBarHidden(): boolean;
    getTitleBarOffset(): number;
    isStatusBarHidden(): boolean;
    isActivityBarHidden(): boolean;
    setActivityBarHidden(hidden: boolean): void;
    isSideBarHidden(): boolean;
    setSideBarHidden(hidden: boolean): TPromise<void>;
    isPanelHidden(): boolean;
    setPanelHidden(hidden: boolean): TPromise<void>;
    toggleMaximizedPanel(): void;
    isPanelMaximized(): boolean;
    getSideBarPosition(): number;
    addClass(clazz: string): void;
    removeClass(clazz: string): void;
    getWorkbenchElementId(): string;
    toggleZenMode(): void;
    resizePart(part: Parts, sizeChange: number): void;
}
export declare class TestStorageService extends EventEmitter implements IStorageService {
    _serviceBrand: any;
    private storage;
    constructor();
    store(key: string, value: any, scope?: StorageScope): void;
    remove(key: string, scope?: StorageScope): void;
    get(key: string, scope?: StorageScope, defaultValue?: string): string;
    getInteger(key: string, scope?: StorageScope, defaultValue?: number): number;
    getBoolean(key: string, scope?: StorageScope, defaultValue?: boolean): boolean;
}
export declare class TestEditorGroupService implements IEditorGroupService {
    _serviceBrand: any;
    private stacksModel;
    private _onEditorsChanged;
    private _onEditorOpenFail;
    private _onEditorsMoved;
    private _onGroupOrientationChanged;
    private _onTabOptionsChanged;
    constructor(callback?: (method: string) => void);
    fireChange(): void;
    readonly onEditorsChanged: Event<void>;
    readonly onEditorOpenFail: Event<IEditorInput>;
    readonly onEditorsMoved: Event<void>;
    readonly onGroupOrientationChanged: Event<void>;
    readonly onTabOptionsChanged: Event<ITabOptions>;
    focusGroup(group: IEditorGroup): void;
    focusGroup(position: Position): void;
    activateGroup(group: IEditorGroup): void;
    activateGroup(position: Position): void;
    moveGroup(from: IEditorGroup, to: IEditorGroup): void;
    moveGroup(from: Position, to: Position): void;
    arrangeGroups(arrangement: GroupArrangement): void;
    setGroupOrientation(orientation: GroupOrientation): void;
    getGroupOrientation(): GroupOrientation;
    resizeGroup(position: Position, groupSizeChange: number): void;
    pinEditor(group: IEditorGroup, input: IEditorInput): void;
    pinEditor(position: Position, input: IEditorInput): void;
    unpinEditor(group: IEditorGroup, input: IEditorInput): void;
    unpinEditor(position: Position, input: IEditorInput): void;
    moveEditor(input: IEditorInput, from: IEditorGroup, to: IEditorGroup, moveOptions?: IMoveOptions): void;
    moveEditor(input: IEditorInput, from: Position, to: Position, moveOptions?: IMoveOptions): void;
    getStacksModel(): EditorStacksModel;
    getTabOptions(): ITabOptions;
}
export declare class TestEditorService implements IWorkbenchEditorService {
    _serviceBrand: any;
    activeEditorInput: IEditorInput;
    activeEditorOptions: IEditorOptions;
    activeEditorPosition: Position;
    mockLineNumber: number;
    private callback;
    constructor(callback?: (method: string) => void);
    openEditors(inputs: any): Promise;
    replaceEditors(editors: any): TPromise<IEditor[]>;
    closeEditors(position: Position, filter?: {
        except?: IEditorInput;
        direction?: Direction;
        unmodifiedOnly?: boolean;
    }): TPromise<void>;
    closeAllEditors(except?: Position): TPromise<void>;
    isVisible(input: IEditorInput, includeDiff: boolean): boolean;
    getActiveEditor(): IEditor;
    getActiveEditorInput(): IEditorInput;
    getVisibleEditors(): IEditor[];
    openEditor(input: any, options?: any, position?: any): Promise;
    closeEditor(position: Position, input: IEditorInput): TPromise<void>;
    createInput(input: IResourceInput): IEditorInput;
}
export declare class TestFileService implements IFileService {
    _serviceBrand: any;
    private _onFileChanges;
    private _onAfterOperation;
    constructor();
    readonly onFileChanges: Event<FileChangesEvent>;
    fireFileChanges(event: FileChangesEvent): void;
    readonly onAfterOperation: Event<FileOperationEvent>;
    fireAfterOperation(event: FileOperationEvent): void;
    resolveFile(resource: URI, options?: IResolveFileOptions): TPromise<IFileStat>;
    resolveFiles(toResolve: {
        resource: URI;
        options?: IResolveFileOptions;
    }[]): TPromise<IResolveFileResult[]>;
    existsFile(resource: URI): TPromise<boolean>;
    resolveContent(resource: URI, options?: IResolveContentOptions): TPromise<IContent>;
    resolveStreamContent(resource: URI, options?: IResolveContentOptions): TPromise<IStreamContent>;
    updateContent(resource: URI, value: string, options?: IUpdateContentOptions): TPromise<IFileStat>;
    moveFile(source: URI, target: URI, overwrite?: boolean): TPromise<IFileStat>;
    copyFile(source: URI, target: URI, overwrite?: boolean): TPromise<IFileStat>;
    createFile(resource: URI, content?: string): TPromise<IFileStat>;
    createFolder(resource: URI): TPromise<IFileStat>;
    rename(resource: URI, newName: string): TPromise<IFileStat>;
    touchFile(resource: URI): TPromise<IFileStat>;
    del(resource: URI, useTrash?: boolean): TPromise<void>;
    importFile(source: URI, targetFolder: URI): TPromise<IImportResult>;
    watchFileChanges(resource: URI): void;
    unwatchFileChanges(resource: URI): void;
    updateOptions(options: any): void;
    getEncoding(resource: URI): string;
    dispose(): void;
}
export declare class TestBackupFileService implements IBackupFileService {
    _serviceBrand: any;
    backupEnabled: boolean;
    hasBackups(): TPromise<boolean>;
    hasBackup(resource: URI): TPromise<boolean>;
    loadBackupResource(resource: URI): TPromise<URI>;
    registerResourceForBackup(resource: URI): TPromise<void>;
    deregisterResourceForBackup(resource: URI): TPromise<void>;
    getBackupResource(resource: URI): URI;
    backupResource(resource: URI, content: string): TPromise<void>;
    getWorkspaceFileBackups(): TPromise<URI[]>;
    parseBackupContent(rawText: IRawTextSource): string;
    discardResourceBackup(resource: URI): TPromise<void>;
    discardAllWorkspaceBackups(): TPromise<void>;
}
export declare class TestWindowService implements IWindowService {
    _serviceBrand: any;
    onDidChangeFocus: Event<boolean>;
    isFocused(): TPromise<boolean>;
    getCurrentWindowId(): number;
    pickFileFolderAndOpen(options: INativeOpenDialogOptions): TPromise<void>;
    pickFileAndOpen(options: INativeOpenDialogOptions): TPromise<void>;
    pickFolderAndOpen(options: INativeOpenDialogOptions): TPromise<void>;
    reloadWindow(): TPromise<void>;
    openDevTools(): TPromise<void>;
    toggleDevTools(): TPromise<void>;
    closeWorkspace(): TPromise<void>;
    openWorkspace(): TPromise<void>;
    createAndOpenWorkspace(folders?: string[], path?: string): TPromise<void>;
    saveAndOpenWorkspace(path: string): TPromise<void>;
    toggleFullScreen(): TPromise<void>;
    setRepresentedFilename(fileName: string): TPromise<void>;
    getRecentlyOpened(): TPromise<IRecentlyOpened>;
    focusWindow(): TPromise<void>;
    closeWindow(): TPromise<void>;
    setDocumentEdited(flag: boolean): TPromise<void>;
    isMaximized(): TPromise<boolean>;
    maximizeWindow(): TPromise<void>;
    unmaximizeWindow(): TPromise<void>;
    onWindowTitleDoubleClick(): TPromise<void>;
    showMessageBox(options: Electron.ShowMessageBoxOptions): number;
    showSaveDialog(options: Electron.SaveDialogOptions, callback?: (fileName: string) => void): string;
    showOpenDialog(options: Electron.OpenDialogOptions, callback?: (fileNames: string[]) => void): string[];
}
export declare class TestLifecycleService implements ILifecycleService {
    _serviceBrand: any;
    phase: LifecyclePhase;
    startupKind: StartupKind;
    private _onDidChangePhase;
    private _onWillShutdown;
    private _onShutdown;
    fireShutdown(reason?: ShutdownReason): void;
    fireWillShutdown(event: ShutdownEvent): void;
    readonly onDidChangePhase: Event<LifecyclePhase>;
    readonly onWillShutdown: Event<ShutdownEvent>;
    readonly onShutdown: Event<ShutdownReason>;
}
export declare class TestWindowsService implements IWindowsService {
    _serviceBrand: any;
    windowCount: number;
    onWindowOpen: Event<number>;
    onWindowFocus: Event<number>;
    onWindowBlur: Event<number>;
    isFocused(windowId: number): TPromise<boolean>;
    pickFileFolderAndOpen(options: INativeOpenDialogOptions): TPromise<void>;
    pickFileAndOpen(options: INativeOpenDialogOptions): TPromise<void>;
    pickFolderAndOpen(options: INativeOpenDialogOptions): TPromise<void>;
    reloadWindow(windowId: number): TPromise<void>;
    openDevTools(windowId: number): TPromise<void>;
    toggleDevTools(windowId: number): TPromise<void>;
    closeWorkspace(windowId: number): TPromise<void>;
    openWorkspace(windowId: number): TPromise<void>;
    createAndOpenWorkspace(windowId: number, folders?: string[], path?: string): TPromise<void>;
    saveAndOpenWorkspace(windowId: number, path: string): TPromise<void>;
    toggleFullScreen(windowId: number): TPromise<void>;
    setRepresentedFilename(windowId: number, fileName: string): TPromise<void>;
    addRecentlyOpened(files: string[]): TPromise<void>;
    removeFromRecentlyOpened(paths: string[]): TPromise<void>;
    clearRecentlyOpened(): TPromise<void>;
    getRecentlyOpened(windowId: number): TPromise<IRecentlyOpened>;
    focusWindow(windowId: number): TPromise<void>;
    closeWindow(windowId: number): TPromise<void>;
    isMaximized(windowId: number): TPromise<boolean>;
    maximizeWindow(windowId: number): TPromise<void>;
    unmaximizeWindow(windowId: number): TPromise<void>;
    onWindowTitleDoubleClick(windowId: number): TPromise<void>;
    setDocumentEdited(windowId: number, flag: boolean): TPromise<void>;
    quit(): TPromise<void>;
    relaunch(options: {
        addArgs?: string[];
        removeArgs?: string[];
    }): TPromise<void>;
    whenSharedProcessReady(): TPromise<void>;
    toggleSharedProcess(): TPromise<void>;
    openWindow(paths: string[], options?: {
        forceNewWindow?: boolean;
        forceReuseWindow?: boolean;
        forceOpenWorkspaceAsFile?: boolean;
    }): TPromise<void>;
    openNewWindow(): TPromise<void>;
    showWindow(windowId: number): TPromise<void>;
    getWindows(): TPromise<{
        id: number;
        workspace?: IWorkspaceIdentifier;
        folderPath?: string;
        title: string;
        filename?: string;
    }[]>;
    getWindowCount(): TPromise<number>;
    log(severity: string, ...messages: string[]): TPromise<void>;
    showItemInFolder(path: string): TPromise<void>;
    openExternal(url: string): TPromise<boolean>;
    startCrashReporter(config: Electron.CrashReporterStartOptions): TPromise<void>;
}
