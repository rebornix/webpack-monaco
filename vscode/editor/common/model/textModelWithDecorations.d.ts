import { IMarkdownString } from 'vs/base/common/htmlContent';
import { Range, IRange } from 'vs/editor/common/core/range';
import * as editorCommon from 'vs/editor/common/editorCommon';
import { MarkersTracker, LineMarker } from 'vs/editor/common/model/modelLine';
import { TextModelWithMarkers } from 'vs/editor/common/model/textModelWithMarkers';
import { LanguageIdentifier } from 'vs/editor/common/modes';
import { ITextSource, IRawTextSource } from 'vs/editor/common/model/textSource';
import { ThemeColor } from 'vs/platform/theme/common/themeService';
export declare const ClassName: {
    EditorWarningDecoration: string;
    EditorErrorDecoration: string;
};
export declare class InternalDecoration implements editorCommon.IModelDecoration {
    _internalDecorationBrand: void;
    readonly id: string;
    readonly internalId: number;
    readonly ownerId: number;
    readonly startMarker: LineMarker;
    readonly endMarker: LineMarker;
    options: ModelDecorationOptions;
    isForValidation: boolean;
    range: Range;
    constructor(id: string, internalId: number, ownerId: number, range: Range, startMarker: LineMarker, endMarker: LineMarker, options: ModelDecorationOptions);
    setOptions(options: ModelDecorationOptions): void;
    setRange(multiLineDecorationsMap: {
        [key: string]: InternalDecoration;
    }, range: Range): void;
}
export declare class TextModelWithDecorations extends TextModelWithMarkers implements editorCommon.ITextModelWithDecorations {
    /**
     * Used to workaround broken clients that might attempt using a decoration id generated by a different model.
     * It is not globally unique in order to limit it to one character.
     */
    private readonly _instanceId;
    private _lastDecorationId;
    private _currentDecorationsTracker;
    private _currentDecorationsTrackerCnt;
    private _currentMarkersTracker;
    private _currentMarkersTrackerCnt;
    private _decorations;
    private _internalDecorations;
    private _multiLineDecorationsMap;
    constructor(rawTextSource: IRawTextSource, creationOptions: editorCommon.ITextModelCreationOptions, languageIdentifier: LanguageIdentifier);
    dispose(): void;
    protected _resetValue(newValue: ITextSource): void;
    private static _shouldStartMarkerSticksToPreviousCharacter(stickiness);
    private static _shouldEndMarkerSticksToPreviousCharacter(stickiness);
    _getTrackedRangesCount(): number;
    changeDecorations<T>(callback: (changeAccessor: editorCommon.IModelDecorationsChangeAccessor) => T, ownerId?: number): T;
    private _changeDecorations<T>(decorationsTracker, ownerId, callback);
    deltaDecorations(oldDecorations: string[], newDecorations: editorCommon.IModelDeltaDecoration[], ownerId?: number): string[];
    removeAllDecorationsWithOwnerId(ownerId: number): void;
    getDecorationOptions(decorationId: string): editorCommon.IModelDecorationOptions;
    getDecorationRange(decorationId: string): Range;
    getLineDecorations(lineNumber: number, ownerId?: number, filterOutValidation?: boolean): editorCommon.IModelDecoration[];
    /**
     * Fetch only multi-line decorations that intersect with the given line number range
     */
    private _getMultiLineDecorations(filterRange, filterOwnerId, filterOutValidation);
    private _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation);
    getLinesDecorations(_startLineNumber: number, _endLineNumber: number, ownerId?: number, filterOutValidation?: boolean): editorCommon.IModelDecoration[];
    getDecorationsInRange(range: IRange, ownerId?: number, filterOutValidation?: boolean): editorCommon.IModelDecoration[];
    getAllDecorations(ownerId?: number, filterOutValidation?: boolean): editorCommon.IModelDecoration[];
    protected _acquireMarkersTracker(): MarkersTracker;
    protected _releaseMarkersTracker(): void;
    /**
     * Handle changed markers (i.e. update decorations ranges and return the changed decorations, unique and sorted by id)
     */
    private _handleTrackedMarkers(markersTracker);
    private static _createRangeFromMarkers(startPosition, endPosition);
    private _acquireDecorationsTracker();
    private _releaseDecorationsTracker();
    private _handleTrackedDecorations(decorationsTracker);
    private emitModelDecorationsChangedEvent(e);
    private _normalizeDeltaDecorations(deltaDecorations);
    private _externalDecorationId(internalId);
    private _addDecorationImpl(decorationsTracker, ownerId, _range, options);
    private _addDecorationsImpl(decorationsTracker, ownerId, newDecorations);
    private _changeDecorationImpl(decorationsTracker, decorationId, newRange);
    private _changeDecorationOptionsImpl(decorationsTracker, decorationId, options);
    private _removeDecorationImpl(decorationsTracker, decorationId);
    private _removeDecorationsImpl(decorationsTracker, decorationIds);
    private _resolveOldDecorations(oldDecorations);
    private _deltaDecorationsImpl(decorationsTracker, ownerId, oldDecorationsIds, newDecorations);
}
export declare class ModelDecorationOverviewRulerOptions implements editorCommon.IModelDecorationOverviewRulerOptions {
    readonly color: string | ThemeColor;
    readonly darkColor: string | ThemeColor;
    readonly hcColor: string | ThemeColor;
    readonly position: editorCommon.OverviewRulerLane;
    constructor(options: editorCommon.IModelDecorationOverviewRulerOptions);
    equals(other: ModelDecorationOverviewRulerOptions): boolean;
}
export declare class ModelDecorationOptions implements editorCommon.IModelDecorationOptions {
    static EMPTY: ModelDecorationOptions;
    static register(options: editorCommon.IModelDecorationOptions): ModelDecorationOptions;
    static createDynamic(options: editorCommon.IModelDecorationOptions): ModelDecorationOptions;
    readonly staticId: number;
    readonly stickiness: editorCommon.TrackedRangeStickiness;
    readonly className: string;
    readonly hoverMessage: IMarkdownString | IMarkdownString[];
    readonly glyphMarginHoverMessage: IMarkdownString | IMarkdownString[];
    readonly isWholeLine: boolean;
    readonly showIfCollapsed: boolean;
    readonly overviewRuler: ModelDecorationOverviewRulerOptions;
    readonly glyphMarginClassName: string;
    readonly linesDecorationsClassName: string;
    readonly marginClassName: string;
    readonly inlineClassName: string;
    readonly beforeContentClassName: string;
    readonly afterContentClassName: string;
    private constructor();
    equals(other: ModelDecorationOptions): boolean;
}
