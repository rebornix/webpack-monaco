import { Range } from 'vs/editor/common/core/range';
import * as editorCommon from 'vs/editor/common/editorCommon';
import { TextModel } from 'vs/editor/common/model/textModel';
import { LanguageId, LanguageIdentifier } from 'vs/editor/common/modes';
import { IPosition } from 'vs/editor/common/core/position';
import { LineTokens } from 'vs/editor/common/core/lineTokens';
import { ITextSource, IRawTextSource } from 'vs/editor/common/model/textSource';
export declare class TextModelWithTokens extends TextModel implements editorCommon.ITokenizedModel {
    private static MODE_TOKENIZATION_FAILED_MSG;
    private _languageIdentifier;
    private _tokenizationListener;
    private _tokenizationSupport;
    private _invalidLineStartIndex;
    private _lastState;
    private _revalidateTokensTimeout;
    constructor(rawTextSource: IRawTextSource, creationOptions: editorCommon.ITextModelCreationOptions, languageIdentifier: LanguageIdentifier);
    dispose(): void;
    protected _shouldAutoTokenize(): boolean;
    protected _resetValue(newValue: ITextSource): void;
    protected _resetTokenizationState(): void;
    private _clearTimers();
    private _withModelTokensChangedEventBuilder<T>(callback);
    forceTokenization(lineNumber: number): void;
    isCheapToTokenize(lineNumber: number): boolean;
    tokenizeIfCheap(lineNumber: number): void;
    getLineTokens(lineNumber: number): LineTokens;
    private _getLineTokens(lineNumber);
    getLanguageIdentifier(): LanguageIdentifier;
    getModeId(): string;
    setMode(languageIdentifier: LanguageIdentifier): void;
    getLanguageIdAtPosition(_lineNumber: number, _column: number): LanguageId;
    protected _invalidateLine(lineIndex: number): void;
    private _beginBackgroundTokenization();
    _warmUpTokens(): void;
    private _revalidateTokensNow(toLineNumber?);
    private _updateTokensUntilLine(eventBuilder, lineNumber);
    private emitModelTokensChangedEvent(e);
    private _emitModelModeChangedEvent(e);
    getWordAtPosition(_position: IPosition): editorCommon.IWordAtPosition;
    getWordUntilPosition(position: IPosition): editorCommon.IWordAtPosition;
    findMatchingBracketUp(_bracket: string, _position: IPosition): Range;
    matchBracket(position: IPosition): [Range, Range];
    private _matchBracket(position);
    private _matchFoundBracket(foundBracket, data, isOpen);
    private _findMatchingBracketUp(bracket, position);
    private _findMatchingBracketDown(bracket, position);
    findPrevBracket(_position: IPosition): editorCommon.IFoundBracket;
    findNextBracket(_position: IPosition): editorCommon.IFoundBracket;
    private _toFoundBracket(modeBrackets, r);
}
