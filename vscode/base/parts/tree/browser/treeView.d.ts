import Lifecycle = require('vs/base/common/lifecycle');
import Model = require('vs/base/parts/tree/browser/treeModel');
import { HeightMap, IViewItem } from 'vs/base/parts/tree/browser/treeViewModel';
import _ = require('vs/base/parts/tree/browser/tree');
import Event from 'vs/base/common/event';
export interface IRow {
    element: HTMLElement;
    templateId: string;
    templateData: any;
}
export declare class RowCache implements Lifecycle.IDisposable {
    private context;
    private _cache;
    constructor(context: _.ITreeContext);
    alloc(templateId: string): IRow;
    release(templateId: string, row: IRow): void;
    private cache(templateId);
    garbageCollect(): void;
    dispose(): void;
}
export interface IViewContext extends _.ITreeContext {
    cache: RowCache;
}
export declare class ViewItem implements IViewItem {
    private context;
    model: Model.Item;
    id: string;
    protected row: IRow;
    top: number;
    height: number;
    onDragStart: (e: DragEvent) => void;
    needsRender: boolean;
    uri: string;
    unbindDragStart: Lifecycle.IDisposable;
    loadingTimer: number;
    _styles: any;
    private _draggable;
    constructor(context: IViewContext, model: Model.Item);
    expanded: boolean;
    loading: boolean;
    draggable: boolean;
    dropTarget: boolean;
    readonly element: HTMLElement;
    private _templateId;
    private readonly templateId;
    addClass(name: string): void;
    removeClass(name: string): void;
    render(skipUserRender?: boolean): void;
    insertInDOM(container: HTMLElement, afterElement: HTMLElement): void;
    removeFromDOM(): void;
    dispose(): void;
}
export declare class TreeView extends HeightMap {
    static BINDING: string;
    static LOADING_DECORATION_DELAY: number;
    private static counter;
    private instance;
    private static currentExternalDragAndDropData;
    private context;
    private modelListeners;
    private model;
    private viewListeners;
    private domNode;
    private wrapper;
    private styleElement;
    private rowsContainer;
    private scrollableElement;
    private wrapperGesture;
    private msGesture;
    private lastPointerType;
    private lastClickTimeStamp;
    private lastRenderTop;
    private lastRenderHeight;
    private inputItem;
    private items;
    private isRefreshing;
    private refreshingPreviousChildrenIds;
    private dragAndDropListeners;
    private currentDragAndDropData;
    private currentDropElement;
    private currentDropElementReaction;
    private currentDropTarget;
    private shouldInvalidateDropReaction;
    private currentDropTargets;
    private currentDropPromise;
    private dragAndDropScrollInterval;
    private dragAndDropScrollTimeout;
    private dragAndDropMouseY;
    private didJustPressContextMenuKey;
    private highlightedItemWasDraggable;
    private onHiddenScrollTop;
    private _onDOMFocus;
    readonly onDOMFocus: Event<void>;
    private _onDOMBlur;
    readonly onDOMBlur: Event<void>;
    constructor(context: _.ITreeContext, container: HTMLElement);
    applyStyles(styles: _.ITreeStyles): void;
    protected createViewItem(item: Model.Item): IViewItem;
    getHTMLElement(): HTMLElement;
    focus(): void;
    isFocused(): boolean;
    blur(): void;
    onVisible(): void;
    private setupMSGesture();
    onHidden(): void;
    private isTreeVisible();
    layout(height?: number): void;
    private render(scrollTop, viewHeight);
    setModel(newModel: Model.TreeModel): void;
    private onModelEvents(events);
    private onRefreshing();
    private onRefreshed();
    private onRowsChanged(scrollTop?);
    focusNextPage(eventPayload?: any): void;
    focusPreviousPage(eventPayload?: any): void;
    viewHeight: number;
    scrollTop: number;
    getScrollPosition(): number;
    setScrollPosition(pos: number): void;
    private onClearingInput(e);
    private onSetInput(e);
    private onItemChildrenRefreshing(e);
    private onItemChildrenRefreshed(e);
    private onItemsRefresh(items);
    private onItemExpanding(e);
    private onItemExpanded(e);
    private onItemCollapsing(e);
    getRelativeTop(item: Model.Item): number;
    private onItemReveal(e);
    private onItemAddTrait(e);
    private onItemRemoveTrait(e);
    private onModelFocusChange();
    onInsertItem(item: ViewItem): void;
    onRefreshItem(item: ViewItem, needsRender?: boolean): void;
    onRemoveItem(item: ViewItem): void;
    private refreshViewItem(item);
    private onClick(e);
    private onMouseDown(e);
    private onMouseUp(e);
    private onTap(e);
    private onTouchChange(event);
    private onContextMenu(keyboardEvent);
    private onContextMenu(mouseEvent);
    private onKeyDown(e);
    private onKeyUp(e);
    private onDragStart(item, e);
    private setupDragAndDropScrollInterval();
    private cancelDragAndDropScrollInterval();
    private cancelDragAndDropScrollTimeout();
    private onDragOver(e);
    private onDrop(e);
    private onDragEnd(e);
    private onFocus();
    private onBlur();
    private onMsPointerDown(event);
    private onThrottledMsGestureChange(event);
    private onMsGestureTap(event);
    private insertItemInDOM(item);
    private removeItemFromDOM(item);
    private shouldBeRendered(item);
    private getItemAround(element);
    private releaseModel();
    dispose(): void;
}
